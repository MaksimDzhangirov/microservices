# Шаблон: Монолитная архитектура

[Оригинал](https://microservices.io/patterns/monolithic.html)

## Дано

Вы разрабатываете серверное корпоративное приложение. Он должен поддерживать 
множество различных клиентов, включая настольные браузеры, мобильные 
браузеры и нативные мобильные приложения. Приложение также может 
предоставлять API для использования третьими сторонами. Он также может 
интегрироваться с другими приложениями через веб-сервисы или брокер 
сообщений. Приложение обрабатывает запросы (HTTP-запросы и сообщения), 
выполняя бизнес-логику; обращаясь к базе данных; обмениваясь сообщениями с 
другими системами; и возвращая HTML/JSON/XML ответ. Существуют логические 
компоненты, соответствующие разным функциональным областям приложения.

## Задача

Какую архитектуру использовать для развертывания приложения?

## Дополнительные условия

* Над приложением работает команда разработчиков
* Новые члены команды должны быстро начать приносить пользу
* Приложение должно быть простым для понимания и изменения
* Вы хотите практиковать непрерывное развертывание приложения
* Вы должны запускать несколько экземпляров приложения на нескольких 
  компьютерах, чтобы удовлетворить требования масштабируемости и доступности
* Вы хотите использовать новые технологии (фреймворки, языки программирования 
  и т.д.)

## Решение

Создайте приложение с монолитной архитектурой. Например, используя:

* единый Java WAR-файл;
* единое дерево каталогов с исходным кодом на Rails или NodeJS.

## Пример

Давайте представим, что вы создаете приложение для онлайн-продаж, которое
принимает заказы от клиентов, проверяет на наличие товары в нём и доступный 
кредит и отправляет их. Приложение состоит из нескольких компонентов, 
включая StoreFrontUI, который реализует пользовательский интерфейс, а также 
некоторых серверных сервисов для проверки кредита, наличия товаров и 
отправки заказов.

Приложение развертывается как единое монолитное приложение. Например, 
веб-приложение на языке Java состоит из единого WAR-файла, который 
выполняется в веб-контейнере, таком как Tomcat. Rails Приложение состоит из 
единого дерева каталогов, развернутого с использованием, например, 
Phusion Passenger на Apache/Nginx или JRuby на Tomcat. Вы можете запускать 
несколько экземпляров приложения за балансировщиком нагрузки, чтобы 
масштабировать и улучшать доступность.

![](../../../images/pattern-monolithic-architecture/DecomposingApplications.011.jpg)

## Преимущества и недостатки

Это решение имеет ряд преимуществ:

* *Простота разработки* — современные средства разработки и IDE 
  специализируются на поддержке разработки монолитных приложений
* *Простота развертывания* — Вам просто нужно развернуть WAR-файл (или дерево
  каталогов) в соответствующей среде выполнения
* *Простота масштабирования* — Вы можете масштабировать приложение, 
  запуская несколько копий приложения за балансировщиком нагрузки

Однако, как только приложение становится большим, а команда увеличивается 
в размерах, этот подход имеет ряд недостатков, которые становятся все более 
значительными:

* Большая монолитная кодовая база отпугивает разработчиков, особенно 
  новичков в команде. Приложение может быть трудно понять и изменить. В 
  результате развитие обычно замедляется. Кроме того, поскольку жестких 
  границ между модулями нет, модульность со временем нарушается. Более того, 
  из-за того, что может быть сложно понять, как правильно реализовать 
  изменение, качество кода со временем снижается. Это нисходящая спираль.

* Медленная работа IDE из-за большой нагрузки — чем больше кодовая база, 
  тем медленнее IDE и тем менее продуктивны разработчики.

* Медленная работа веб-контейнера из-за большой нагрузки — чем больше 
  приложение, тем больше времени требуется для его запуска. Это оказывает
  огромное влияние на производительность разработчиков из-за потери времени 
  на ожидание запуска контейнера. Это также влияет на развертывание.
* Непрерывное развертывание затруднено — большое монолитное приложение 
  также является препятствием для частых развертываний. Чтобы обновить одну 
  составляющую, необходимо повторно развернуть все приложение. Это прервет 
  фоновые задачи (например, задания Quartz в приложении Java), независимо 
  от того, затронуты ли они изменением, и, возможно, приведёт к проблемам.
  Существует также вероятность того, что составляющие, которые не были 
  обновлены, не запустятся правильно. В результате возрастает риск, 
  связанный с повторным развертыванием, что препятствует частым обновлениям.
  Это проблема стоит особо остро для разработчиков пользовательского 
  интерфейса, поскольку им обычно приходится часто вносить изменения и 
  повторно развертывать приложение.
* Масштабирование приложения может быть затруднено — монолитная архитектура 
  такова, что она может масштабироваться только в одном измерении. С одной 
  стороны, его можно масштабировать при увеличении объёма транзакций за 
  счёт запуска большего количества копий приложения. Некоторые облака 
  могут даже динамически регулировать количество экземпляров в зависимости от 
  нагрузки. Но с другой стороны, эта архитектура не может масштабироваться при
  увеличении объема данных. Каждая копия экземпляра приложения будет иметь 
  доступ ко всем данным, что снижает эффективность кэширования и увеличивает 
  потребление памяти и трафик ввода-вывода. Кроме того, разные составляющие 
  приложения могут иметь различные требования к ресурсам — одни могут 
  интенсивно использовать ЦП, а другие — память. В монолитной архитектуре 
  мы не можем масштабировать каждую составляющую независимо.
* Препятствие для масштабируемой разработки — монолитное приложение также 
  является препятствием для масштабируемой разработки. Как только приложение 
  достигает определенного размера, полезно разделить команду разработки на 
  группы, которые сосредоточены на определенных функциональных областях. 
  Например, нам может понадобиться группа, специализирующаяся на 
  пользовательском интерфейсе, бухгалтерском учёте, работающая со складскими
  запасами и т. д. Проблема монолитного приложения заключается в том, что 
  оно не позволяет группам работать независимо. Команды должны 
  координировать свои действия по разработке и повторном развертывании. 
  Команде намного сложнее внести изменения и обновить продакшен.
* Требует долгосрочной привязки к стеку технологий — монолитная архитектура
  заставляет вас использовать стек технологий (а в некоторых случаях и 
  конкретную версию этой технологии), который вы выбрали в начале разработки.
  В случае монолитного приложения может быть сложно поэтапно внедрить новую 
  технологию. Например, давайте представим, что вы выбрали JVM. У вас есть 
  некоторая свобода в выборе языка помимо Java вы можете использовать другие 
  языки JVM, которые хорошо взаимодействуют с Java, например, Groovy и Scala.
  Но составляющие, написанным на языках, отличных от JVM, не могут быть
  частью вашей монолитной архитектуры. Кроме того, если ваше приложение 
  использует фреймворк, который впоследствии устаревает, может возникнуть 
  проблема постепенного переноса приложения на более новый и лучший 
  фреймворк. Вполне возможно, что для того, чтобы адаптировать приложение к
  новому фреймворку, вам придется переписать все приложение, что может
  оказаться рискованной затеей. 

## Связанные шаблоны

Микросервисная архитектура — это альтернативный шаблон, устраняющий 
ограничения монолитной архитектуры.

## Кто использует такой подход

Известные интернет-сервисы, например, Netflix, Amazon.com и eBay, изначально 
имели монолитную архитектуру. Большинство веб-приложений, разработанных 
автором (Крисом Ричардсоном), имели монолитную архитектуру.

## Разновидности