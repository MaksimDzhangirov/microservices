# Шаблон: Микросервисная архитектура

[Оригинал](https://microservices.io/patterns/microservices.html)

## Дано

Вы разрабатываете серверное корпоративное приложение. Он должен поддерживать
множество различных клиентов, включая настольные браузеры, мобильные
браузеры и нативные мобильные приложения. Приложение также может
предоставлять API для использования третьими сторонами. Он также может
интегрироваться с другими приложениями через веб-сервисы или брокер
сообщений. Приложение обрабатывает запросы (HTTP-запросы и сообщения),
выполняя бизнес-логику; обращаясь к базе данных; обмениваясь сообщениями с
другими системами; и возвращая HTML/JSON/XML ответ. Существуют логические
компоненты, соответствующие разным функциональным областям приложения.

## Задача

Какую архитектуру использовать для развертывания приложения?

## Дополнительные условия

* Над приложением работает команда разработчиков
* Новые члены команды должны быстро начать приносить пользу
* Приложение должно быть простым для понимания и изменения
* Вы хотите практиковать непрерывное развертывание приложения
* Вы должны запускать несколько экземпляров приложения на нескольких
  компьютерах, чтобы удовлетворить требования масштабируемости и доступности
* Вы хотите использовать новые технологии (фреймворки, языки программирования 
  и т.д.)

## Решение

Определим архитектуру, которая структурирует приложение как набор слабо 
связанных взаимодействующих сервисов. Этот подход соответствует оси Y
трехмерной модели масштабирования в виде куба. Каждый сервис является:

* легко поддерживаемым и тестируемым - позволяет быстро и часто осуществлять
  разработку и развёртывание
* слабо связанным с другими сервисами - позволяет команде большую часть 
  времени работать независимо над своим сервисом (сервисами), не 
  подвергаясь влиянию изменений в других сервисах и не влияя на другие 
  сервисы.
* независимо развёртываемым - позволяет команде развертывать свой сервис 
  без необходимости координировать свои действия с другими командами.
* таким, что его может разрабатывать небольшая команда. Это очень важно для
  высокой производительности команды, поскольку в этом случае не нужен
  вышестоящий руководитель, координирующий действия нескольких команд.

Сервисы обмениваются данными, используя либо синхронные протоколы, таких 
как HTTP/REST, либо асинхронные протоколы, например, AMQP. Сервисы можно 
разрабатывать и развертывать независимо друг от друга. Каждый сервис имеет 
свою собственную базу данных, чтобы не быть связанным с другими сервисами.
Согласованность данных между сервисами поддерживается с помощью шаблона 
Saga.

Что узнать чем на самом деле является сервис, пожалуйста, 
прочитайте эту статью.

## Пример

### Фиктивное приложение для онлайн-продаж

Давайте представим, что вы создаете приложение для онлайн-продаж, 
которое принимает заказы от клиентов, проверяет на наличие товары в нём и 
доступный кредит и отправляет их. Приложение состоит из нескольких компонентов,
включая StoreFrontUI, который реализует пользовательский интерфейс, а также
некоторых серверных сервисов для проверки кредита, наличия товаров и
отправки заказов. Приложение состоит из набора сервисов.

![](../../../images/pattern-microservice-architecture/Microservice_Architecture.png)

### Код приложения

Перейдя по ссылке вы [увидите примеры приложений, разработанные Крисом 
Ричардсоном](http://eventuate.io/exampleapps.html). Эти примеры на GitHub 
иллюстрируют различные аспекты микросервисной архитектуры.

## Преимущества и недостатки

### Преимущества

Это решение имеет ряд преимуществ:

* делает возможными непрерывную доставку и развертывание крупных, сложных 
  приложений
  * улучшает обслуживаемость - каждый сервис относительно небольшой, поэтому 
    его легче понять и изменить
  * улучшает тестируемость - сервисы меньше по размеру и быстрее тестируются
  * Улучшенная развертываемость - сервисы можно развертывать независимо
  * это позволяет организовать разработку, используя несколько автономных 
    команд. Каждая (так называемая «на две пиццы») команда владеет и отвечает 
    за один или несколько сервисов. Каждая команда может разрабатывать, 
    тестировать, развертывать и масштабировать свои сервисы независимо от 
    всех других команд.
* Каждый микросервис относительно мал:
  * его легче понять разработчику
  * IDE работает быстрее, делая разработчиков более продуктивными
  * приложение запускается быстрее, что повышает продуктивность разработчиков
    и ускоряет развертывание
  * улучшенная изоляция неполадок. Например, если в одном сервисе существует 
    утечка памяти, то затронута будет только он. Другие сервисы продолжат 
    обрабатывать запросы. Для сравнения, одна неисправная составляющая 
    монолитной архитектуры может вывести из строя всю систему.
  * устраняет любую долгосрочную зависимость от стека технологий. При 
    разработке нового сервиса вы можете выбрать новый стек технологий. 
    Точно так же при внесении серьезных изменений в существующий сервис,
    вы можете переписать его, используя новый стек технологий.

### Недостатки

Это решение имеет ряд недостатков:

* разработчикам приходится сталкиваться с дополнительной сложностью создания 
  распределенной системы:
  * разработчики должны внедрить механизм межсервисного взаимодействия и 
    справляться с возможными отказами в работе отдельных сервисов
  * реализовать запрос, использующий несколько сервисов, сложнее
  * тестировать взаимодействие между сервисами сложнее
  * выполнение запросов, охватывающих несколько сервисов, требует 
    тщательной координации между командами
  * инструменты разработчика/IDE ориентированы на создание монолитных 
    приложений и не предоставляют явной поддержки для разработки 
    распределенных приложений.
* Сложность развертывания. На продакшене также существует операционная 
  сложность развертывания и управления системой, состоящей из множества 
  различных сервисов
* повышенное потребление памяти. Архитектура микросервисов заменяет N 
  экземпляров монолитных приложений NxM экземплярами сервисов. Если каждый 
  сервис работает в своей собственной JVM (или ее эквиваленте), что обычно 
  необходимо для изоляции экземпляров, то накладные расходы равны M 
  умноженному на количество сред выполнения JVM. Более того, если каждый 
  сервис работает в своей собственной виртуальной машине (например, 
  EC2 инстансе), как в случае с Netflix, накладные расходы ещё больше.
    
## Проблемы, связанные с использованием данной архитектуры

Существует множество проблем, которые вы должны решить.

## Когда стоит применять микросервисную архитектуру?

Одна из проблем, связанных с использованием этого подхода, заключается в том, 
чтобы решить, когда имеет смысл его использовать. При разработке первой 
версии приложения часто не возникает проблем, которые решает этот подход.
Более того, использование сложной распределенной архитектуры замедлит 
разработку. Это может стать серьезной проблемой для стартапов, чьей самым 
большим вызовом часто является быстрое развитие бизнес-модели и 
сопутствующего приложения. Масштабирование по оси Y может затруднить быструю 
итерацию. Однако позже, когда проблема заключается в масштабировании, и 
вам нужно использовать декомпозицию по функционалу, запутанные зависимости 
могут затруднить декомпозицию вашего монолитного приложения на набор сервисов.

## Как декомпозировать приложение на сервисы?

Еще одна проблема заключается в том, чтобы решить, как разделить систему 
на микросервисы. Это во многом искусство, но есть ряд стратегий, которые 
могут помочь:

* [Декомпозируйте по бизнес-возможностям](../Decomposition/decompose-by-business-capability.md) 
  и определите сервисы, соответствующие бизнес-возможностям.
* [Декомпозируйте по подобластям, основанным на предметно-ориентированном
  проектировании](../Decomposition/decompose-by-subdomain.md)
* Декомпозируйте по действию или сценарию использования и определите сервисы, 
  отвечающие за определенные действия, например, сервис доставки (`Shipping 
  Service`), которая отвечает за доставку сформированных заказов.
* Декомпозируйте по существительным или ресурсам, определив сервис, который 
  отвечает за все операции с сущностями/ресурсами данного типа, например, 
  сервис учётных записей (`Account Service`), отвечающий за управление 
  учетными записями пользователей.

В идеале каждый сервис должен иметь лишь небольшой набор обязанностей. (Дядя) 
Боб Мартин рассказывает о проектировании классов с использованием [принципа 
единой ответственности (SRP)](http://www.objectmentor.com/resources/articles/srp.pdf). 
SRP определяет ответственность класса как причину для изменения и утверждает, 
что у класса должна быть только одна причина для изменения. Имеет смысл 
применить SRP и при проектировании сервисов.

Ещё одна аналогия, которая помогает при проектировании сервисов, — это 
проектирование утилит Unix. Unix предоставляет большое количество утилит, 
таких как `grep`, `cat` и `find`. Каждая утилита делает что-то одно, часто
очень хорошо, и нередко она объединяется с другими утилитами внутри
скриптов для оболочки командной строки для выполнения сложных задач.

## Как обеспечить согласованность данных?

Для слабой связанности каждый сервис имеет собственную базу данных. 
Обеспечение согласованности данных между сервисами является сложной задачей,
поскольку двухфазная фиксация/распределенные транзакции не подходят для 
многих приложений. Вместо этого приложение должно использовать [шаблон Saga](../Data-management/saga.md).
Сервис издаёт событие, когда его данные изменяются. Другие сервисы 
используют это событие и обновляют свои данные. Существует несколько 
способов надежного обновления данных и издания событий, включая [генерацию 
событий](../Data-management/event-sourcing.md) и 
[отслеживание лога транзакций](../Transactional-messaging/transaction-log-tailing.md).

## Как реализовать запросы?

Ещё одной проблемой является реализация запросов, которые должны извлекать 
данные, принадлежащие нескольким сервисам.

* Шаблоны [Композиция API](../Data-management/api-composition.md) и [разделение ответственности команд и запросов 
  (CQRS)](../Data-management/cqrs.md)

## Связанные шаблоны

Существует множество шаблонов, связанных с шаблоном микросервисов. Монолитная
архитектура является альтернативой микросервисной архитектуре. Другие шаблоны
решают проблемы, с которыми вы столкнетесь при использовании микросервисной
архитектуры.

![](../../../images/pattern-microservice-architecture/PatternsRelatedToMicroservices.jpg)

* Шаблоны декомпозиции
  * [Декомпозиция по бизнес-возможностям](../Decomposition/decompose-by-business-capability.md)
  * [Декомпозиция по подобластям, основанная на предметно-ориентированном
    проектировании](../Decomposition/decompose-by-subdomain.md)
* [Шаблоны по базе данных на сервис](../Data-management/database-per-service.md)
  описывают каким образом обеспечить слабую связанность путём использования 
  своей собственной базы данных для каждого сервиса.
* [Шаблон API-шлюз]() определяет, как клиенты получают доступ к сервисам в 
  микросервисной архитектуре.
* [Шаблоны обнаружения на стороне клиента]() и [обнаружения на стороне сервера]() 
  используются для маршрутизации запросов от клиента к доступному экземпляру 
  сервиса в микросервисной архитектуре.
* Шаблоны обмена сообщениями и удаленного вызова процедур — это два разных 
  способа взаимодействия сервисов.
* Шаблоны [Один сервис на хост](../Deployment-patterns/single-service-per-host.md) и
  [Несколько сервисов на хост](../Deployment-patterns/multiple-services-per-host.md) — это
  две разные стратегии развертывания.
* Шаблоны, затрагивающие несколько областей: [шаблон микросервисного шасси]() и 
  [шаблон внешняя конфигурация]()
* Шаблоны тестирования: [компонентное тестирование сервиса]() и [интеграционные 
  тесты сервиса с использованием контракта]()
* [Circuit Breaker]()
* [Токен доступа]()
* Шаблоны наблюдаемости:
  * [Агрегация логов]()
  * [Метрики приложения]()
  * [Ведение лога аудита]()
  * [Распределенная трассировка]()
  * [Отслеживание исключений]()
  * [API проверки работоспособности]()
  * [Лог развертываний и изменений]()
* Шаблоны пользовательского интерфейса
  * [Композиция фрагмента страницы на стороне сервера]()
  * [Композиция пользовательского интерфейса на стороне клиента]()

## Кто использует такой подход

Большинство крупных веб-сайтов, включая [Netflix](http://techblog.netflix.com/), 
[Amazon](http://highscalability.com/blog/2007/9/18/amazon-architecture.html) и 
[eBay](http://www.addsimplicity.com/downloads/eBaySDForum2006-11-29.pdf), 
эволюционировали из монолитной архитектуры в микросервисную.

Netflix, очень популярный сервис потокового видео, на долю которого 
приходится до 30% интернет-трафика, имеет широкомасштабную 
сервисно-ориентированную архитектуру. Он обрабатывает более миллиарда 
запросов в день к своему API потоковой передачи видео с более чем 800 
различных типов устройств. Каждый вызов API разветвляется в среднем на 
шесть вызовов сервисов на сервере.

[Amazon.com](http://amazon.com/) изначально имел двухуровневую архитектуру. 
Для масштабирования они перешли на сервис-ориентированную архитектуру, 
состоящую из сотен бекэнд сервисов. Несколько приложений вызывают эти 
сервисы, включая приложения, которые реализуют веб-сайт [Amazon.com](http://amazon.com/)
и API веб-сервисы. Приложение веб-сайта [Amazon.com](http://amazon.com/) 
обращается к 100-150 сервисам, чтобы получить данные, которые использовались 
для создания веб-страницы.

Сайт-аукцион [ebay.com](http://ebay.com/) также эволюционировал из монолитной
архитектуры в сервис-ориентированную. Прикладной уровень состоит из 
нескольких независимых приложений. Каждое приложение реализует бизнес-логику 
для определенной функционала, такого как покупка или продажа. Каждое 
приложение использует масштабирование по оси X, а некоторые приложения, 
такие как поиск, используют масштабирование по оси Z. [Ebay.com](http://ebay.com/)
также использует комбинацию из X-, Y- и Z-масштабирования для базы данных.

Существует [множество других примеров](https://microservices.io/articles/whoisusingmicroservices.html)
компаний, использующих микросервисную архитектуру.

## Примеры

У Криса Ричардсона есть [примеры](http://eventuate.io/exampleapps.html) 
приложений на основе микросервисов.

## Смотрите также

Смотри также мой [основной доклад на Code Freeze 2018](https://microservices.io/microservices/news/2018/02/20/no-such-thing-as-a-microservice.html),
в котором даётся хорошее введение в микросервисную архитектуру.