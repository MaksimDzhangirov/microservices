# Шаблон: Сага

[Оригинал](https://microservices.io/patterns/data/saga.html)

## Дано

Вы воспользовались шаблоном [По базе данных на сервис](database-per-service.md). Каждый
сервис имеет свою базу данных. Однако некоторые бизнес-транзакции охватывают 
несколько сервисов, поэтому вам нужен механизм для реализации транзакций, 
которые охватывают сервисы. Например, давайте представим, что вы создаете 
магазин для онлайн-продаж, в котором у клиентов есть кредитный лимит.
Приложение должно гарантировать, что новый заказ не превысит кредитный 
лимит клиента. Поскольку заказы и клиенты находятся в разных базах данных, 
принадлежащих разным сервисам, приложение не может просто использовать 
локальную ACID транзакцию.

## Хотите больше узнать об этом шаблоне?

Взгляните на мой [онлайн-учебный курс для самостоятельного изучения](https://chrisrichardson.net/virtual-bootcamp-distributed-data-management.html), который 
научит вас использовать шаблоны Saga, Композиция API и CQRS для создания
операций, охватывающих несколько сервисов

Обычно стоимость курса составляет 395 долларов США на человека, но используя 
купон WSSEULWL вы сможете зарегистрироваться за 190 долларов США (действителен
до 30 ноября 2022 г.)

![](../../../images/saga/Microservices_IO_Logo_White.png)

## Задача

Как реализовать транзакции, охватывающие несколько сервисов?

## Дополнительные условия

* [2PC](https://en.wikipedia.org/wiki/Two-phase_commit_protocol) использовать
  не вариант

## Решение

Реализуйте каждую бизнес-транзакцию, охватывающую несколько сервисов, с 
помощью саги. Сага — это последовательность локальных транзакций. Каждая 
локальная транзакция обновляет базу данных и публикует сообщение или 
событие, чтобы инициировать следующую локальную транзакцию в саге.
Если локальная транзакция завершается со сбоем из-за нарушения 
бизнес-правила, сага выполняет серию компенсирующих транзакций, которые 
отменяют изменения, внесенные предыдущими локальными транзакциями.

![](../../../images/saga/From_2PC_To_Saga.png)

Существует два способа согласования саг:

* Хореография — каждая локальная транзакция публикует события предметной 
  области, которые запускают локальные транзакции в других сервисах
* Оркестрация — оркестратор (объект) сообщает участникам, какие локальные 
  транзакции выполнять

## Пример: Сага, основанная на хореографии

![](../../../images/saga/Create_Order_Saga.png)

Приложение для онлайн-продаж, использующее этот подход, создаст заказ, 
используя основанную на хореографии сагу, состоящую из следующих шагов:

1. `Order Service` получает запрос `POST /orders` и создает `Order` (заказ) c 
   состоянием `PENDING` (в ожидании)
2. Затем он генерирует событие `Order Created`.
3. Обработчик событий `Customer Service` пытается зарезервировать кредит, 
   равный сумме заказа
4. Затем он генерирует событие, на основании того получилось у него или нет
5. Обработчик событий `Order Service` либо подтверждает успешное оформление, 
   либо отменяет `Order` (заказ)

## Пример: Сага, основанная на оркестрации

![](../../../images/saga/Create_Order_Saga_Orchestration.png)

Приложение для онлайн-продаж, использующее этот подход, создаст заказ,
используя основанную на оркестрации сагу, состоящую из следующих шагов:

1. `Order Service` получает запрос `POST /orders` и создает оркестратор 
   саги `Create Order`
2. Оркестратор саги создаёт `Order` (заказ) в состоянии `PENDING` (в ожидании)
3. Затем он отправляет команду `Reserve Credit` («Зарезервировать кредит»)
   в `Customer Service`
4. `Customer Service` пытается зарезервировать кредит
5. Затем он отправляет обратно ответное сообщение с указанием получилось
   у него или нет
6. Организатор саги либо подтверждает успешное оформление, либо 
   отменяет `Order` (заказ)

## Преимущества и недостатки

Этот шаблон имеет следующие преимущества:

* Это позволяет приложению поддерживать согласованность данных между 
  несколькими сервисами без использования распределенных транзакций

Это решение имеет следующие недостатки:

* Модель программы более сложная. Например, разработчик должен разработать 
  компенсационные транзакции, которые явно отменяют изменения, сделанные 
  ранее в саге.

Также необходимо решить следующие вопросы:
  * Для отказоустойчивой работы сервис должна автоматически обновлять свою 
    базу данных и публиковать сообщение/событие. Он не может использовать 
    традиционный механизм распределенной транзакции, охватывающий базу 
    данных и брокер сообщений. Вместо этого он должен использовать один из 
    шаблонов, перечисленных ниже
  * Клиент, который инициирует сагу, представляющую собой асинхронный поток 
    с использованием синхронного запроса (например, HTTP `POST/orders`), 
    должен иметь возможность определить её результат выполнения. Существует 
    несколько вариантов, каждый со своими компромиссами:
    * Сервис отправляет результат после завершения саги, например, после 
      получения события `Order Approved` («заказ успешно оформлен») или 
      `Order Rejected` («заказ отменён»)
    * Сервис отправляет результат (например, содержащий идентификатор 
      заказа) после запуска саги, и клиент периодически опрашивает 
      (например, `GET /orders/{orderID}`), чтобы определить результат
    * Сервис отправляет результат (например, содержащий идентификатор 
      заказа) после запуска саги, а затем отправляет событие (например, 
      через веб-сокет, веб-хук и т. д.) клиенту после завершения саги

## Связанные шаблоны

* Шаблон [По базе данных на сервис](database-per-service.md) создает 
  необходимость использования этого шаблона
* Шаблоны, приведённые ниже — это способы атомарного обновления состояния 
  и публикации сообщений/событий:
  * [Генерация событий](event-sourcing.md)
  * [Таблица исходящих транзакций](../Transactional-messaging/transactional-outbox.md)
* Сага, основанная на хореографии, может публиковать события с помощью
  [агрегатов](aggregate.md) и [событий предметной области](domain-event.md)

## Где можно получить более подробную информацию

* В моей книге [Микросервисы. Паттерны разработки и рефакторинга](https://microservices.io/book) этот
  шаблон описан более подробно. [Пример приложения](https://github.com/microservice-patterns/ftgo-application) из 
  книги реализует саги, основанную на оркестрации, используя [фреймворк Eventuate Tram Sagas](https://github.com/eventuate-tram/eventuate-tram-sagas)
* Взгляните на мой [онлайн-учебный курс для самостоятельного изучения](https://chrisrichardson.net/virtual-bootcamp-distributed-data-management.html), который
  научит вас использовать шаблоны Saga, Композиция API и CQRS для создания
  операций, охватывающих несколько сервисов
* Прочитайте эти статьи в блоге о шаблоне Saga:
  * [краткий обзор саг](https://chrisrichardson.net/post/antipatterns/2019/07/09/developing-sagas-part-1.html)
  * [механизмы координации саги: хореография и оркестровка](https://chrisrichardson.net/post/sagas/2019/08/04/developing-sagas-part-2.html)
  * [реализация саг, основанных на хореографии](https://chrisrichardson.net/post/sagas/2019/08/15/developing-sagas-part-3.html)
  * [реализация саг, основанных на оркестрации](https://chrisrichardson.net/post/sagas/2019/12/12/developing-sagas-part-4.html)
* Мои [презентации](https://microservices.io/presentations) по сагам и 
  асинхронным микросервисам


## Пример кода

Ниже приведены различные примеры реализации сервисов для работы с
клиентами и заказами:

* [Сага, основанная на хореографии](https://github.com/eventuate-tram/eventuate-tram-examples-customers-and-orders), где 
  сервисы публикуют события предметной области с помощью [фреймфорка Eventuate Tram](https://github.com/eventuate-tram/eventuate-tram-core)
* [Сага, основанная на оркестрации](https://github.com/eventuate-tram/eventuate-tram-sagas-examples-customers-and-orders), в которой
  `Order Service` применяет оркестратор саги, реализованный с использованием
  [фреймфорка Eventuate Tram Sagas](https://github.com/eventuate-tram/eventuate-tram-sagas)
* [Сага, основанная на хореографии и генерации событий](https://github.com/eventuate-examples/eventuate-examples-java-customers-and-orders), где
  сервисы публикуют события предметной области, используя [фреймворк для 
  генерации событий Eventuate](http://eventuate.io/)