# Шаблон: Генерация событий

[Оригинал](https://microservices.io/patterns/data/event-sourcing.html)

## Дано

От команды сервиса обычно требуется обновить базу данных **и** отправить 
сообщения/события. Например, сервис, участвующий в [саге](saga.md), должен
автоматически обновлять базу данных и отправлять сообщения/события. Точно
так же сервис, который публикует [событие предметной области](domain-event.md), должен 
атомарно обновлять [агрегат](aggregate.md) и публиковать событие.

Сервис должен автоматически обновлять базу данных и отправлять сообщения, 
чтобы избежать несоответствий данных и ошибок. Однако нецелесообразно 
использовать традиционную распределенную транзакцию (2PC), которая 
охватывает базу данных и брокер сообщений для атомарного обновления базы 
данных и публикации сообщений/событий. Брокер сообщений может не 
поддерживать 2PC. И даже если это так, часто нежелательно связывать сервис
как с базой данных, так и с сообщением.

Но без использования 2PC отправка сообщения в середине транзакции 
ненадежна. Нет никакой гарантии, что транзакция будет зафиксирована. Точно 
так же, если сервис отправляет сообщение после фиксации транзакции, нет 
гарантии, что он не выйдет из строя до отправки сообщения.

Кроме того, сообщения должны отправляться брокеру сообщений в том порядке, 
в котором они были отправлены сервисом. Обычно они должны доставляться 
каждому потребителю в одном и том же порядке, хотя это выходит за рамки 
данного шаблона. Например, предположим, что агрегат обновляется серией 
транзакций `T1`, `T2` и т. д. Эти транзакции могут осуществляться одним и 
тем же экземпляром сервиса или разными экземплярами сервиса. Каждая 
транзакция публикует соответствующее событие: `T1 -> E1`, `T2 -> E2` и
т. д. Поскольку `T1` предшествует `T2`, событие `E1` должно быть опубликовано 
до `E2`.

## Задача

Как надежно/атомарно обновлять базу данных и отправлять сообщения/события?

## Дополнительные условия

* [2PC](https://en.wikipedia.org/wiki/Two-phase_commit_protocol) использовать не вариант
* Если транзакция базы данных фиксируется, сообщения должны быть отправлены. 
  И наоборот, если база данных откатывается, сообщения не должны отправляться
* Сообщения должны отправляться брокеру сообщений в том порядке, в котором 
  они были отправлены сервисом. Этот порядок должен сохраняться для случая,
  когда несколько экземпляров сервиса обновляют один и тот же агрегат

## Решение

Хорошим решением этой проблемы является использование генерации событий. 
Генерация событий сохраняет состояние бизнес-объекта, такого как Заказ 
или Клиент, в виде последовательности событий, изменяющих состояние. При 
каждом изменении состояния бизнес-объекта к списку событий добавляется 
новое событие. Поскольку сохранение события — это одна операция, она по 
своей сути является атомарной. Приложение реконструирует текущее состояние 
объекта, воспроизводя события.

Приложения сохраняют события в хранилище событий, которое является базой 
данных событий. Хранилище имеет API для добавления и получения событий 
сущности. Хранилище событий также ведет себя как брокер сообщений. Оно
предоставляет API, который позволяет сервисам подписываться на события. 
Когда сервис сохраняет событие в хранилище событий, оно доставляется всем 
заинтересованным подписчикам.

Некоторые сущности, такие как клиент, могут состоять из большого числа 
событий. Чтобы оптимизировать загрузку, приложение может периодически 
сохранять снимок текущего состояния сущности. Чтобы восстановить текущее 
состояние, приложение находит самый последний снимок и события, произошедшие
после этого снимка. В результате меньше событий требуется до воспроизведения.

## Пример

[Customers and Orders](https://github.com/eventuate-examples/eventuate-examples-java-customers-and-orders) — это 
пример приложения, созданного с использованием Генерации событий и 
[CQRS](cqrs.md). Приложение написано на Java с помощью Spring Boot. Оно
создано с использованием [Eventuate](http://eventuate.io/), платформы для 
приложений, основанной на генерации событий и CQRS.

На следующей диаграмме показано, как он сохраняет заказы.

![](../../../images/event-sourcing/storingevents.png)

Вместо того чтобы просто сохранять текущее состояние каждого заказа в виде
строки в таблице `ORDERS`, приложение сохраняет каждый `Order` (заказ) в 
виде последовательности событий. `CustomerService` (Сервис для работы с 
клиентами) может подписываться на события сервиса для работы с заказами и 
обновлять свое состояние.

Вот агрегат `Order`:

```java
public class Order extends ReflectiveMutableCommandProcessingAggregate<Order, OrderCommand> {

  private OrderState state;
  private String customerId;

  public OrderState getState() {
    return state;
  }

  public List<Event> process(CreateOrderCommand cmd) {
    return EventUtil.events(new OrderCreatedEvent(cmd.getCustomerId(), cmd.getOrderTotal()));
  }

  public List<Event> process(ApproveOrderCommand cmd) {
    return EventUtil.events(new OrderApprovedEvent(customerId));
  }

  public List<Event> process(RejectOrderCommand cmd) {
    return EventUtil.events(new OrderRejectedEvent(customerId));
  }

  public void apply(OrderCreatedEvent event) {
    this.state = OrderState.CREATED;
    this.customerId = event.getCustomerId();
  }

  public void apply(OrderApprovedEvent event) {
    this.state = OrderState.APPROVED;
  }


  public void apply(OrderRejectedEvent event) {
    this.state = OrderState.REJECTED;
  }
```

Вот пример обработчика событий в `CustomerService` (Сервисе для работы с
клиентами), который подписывается на события `Order`:

```java
@EventSubscriber(id = "customerWorkflow")
public class CustomerWorkflow {

  @EventHandlerMethod
  public CompletableFuture<EntityWithIdAndVersion<Customer>> reserveCredit(
          EventHandlerContext<OrderCreatedEvent> ctx) {
    OrderCreatedEvent event = ctx.getEvent();
    Money orderTotal = event.getOrderTotal();
    String customerId = event.getCustomerId();
    String orderId = ctx.getEntityId();

    return ctx.update(Customer.class, customerId, new ReserveCreditCommand(orderTotal, orderId));
  }

}
```

Он обрабатывает событие 'OrderCreated', пытаясь зарезервировать кредит для 
заказа клиента.

Существует [несколько примеров приложений](http://eventuate.io/exampleapps.html), иллюстрирующих 
использование генерации событий.

## Преимущества и недостатки

Генерация событий имеет ряд преимуществ:

* Она решает одну из ключевых проблем при реализации архитектуры, управляемой
  событиями, и позволяет надежно публиковать события при каждом изменении
  состояния
* Поскольку она сохраняет события, а не объекты предметной области, она в 
  основном позволяет избежать проблемы несоответствия объектно-реляционного 
  импеданса
* Она обеспечивает 100% надежный [лог аудита](../Observability/audit-logging.md) изменений, 
  внесенных в бизнес-объект
* Это позволяет реализовать временные запросы, определяющие состояние 
  объекта в любой момент времени
* Бизнес-логика, основанная на генерации событий, состоит из слабо 
  связанных бизнес-сущностей, которые обмениваются событиями. Это значительно 
  упрощает переход от монолитного приложения к микросервисной архитектуре

Генерация событий также имеет ряд недостатков:

* это отличающийся и незнакомый стиль программирования, поэтому он имеет 
  кривую обучения
* из хранилища событий сложно осуществлять выборку, поскольку для 
  восстановления состояния бизнес-сущностей нужно выполнять обычные запросы.
  Скорее всего они будут сложные и неэффективные. В результате приложение 
  должно использовать [Разделение ответственности команд и запросов (CQRS)](cqrs.md) для 
  реализации запросов. Это, в свою очередь, означает, что приложения должны 
  обрабатывать данные, согласованные по событиям.

## Связанные шаблоны

* Шаблоны [Сага](saga.md) и [Событие предметной области](cqrs.md) создают 
  необходимость использования этого шаблона
* [CQRS](cqrs.md) часто приходится использовать при генерации событий
* Генерация событий реализует шаблон [Ведение лога аудита](../Observability/audit-logging.md)

## Смотрите также

* [Eventuate](http://eventuate.io/) — платформа для разработки приложений с использованием 
  Генерации событий и CQRS
* [Статьи о генерации событий и CQRS](http://eventuate.io/articles.html)
* [Как Eventuate реализует снимки](https://blog.eventuate.io/2017/03/07/eventuate-local-now-supports-snapshots/)